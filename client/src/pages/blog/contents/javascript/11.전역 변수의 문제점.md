## 전역 변수의 문제점

전역 변수의 무분별한 사용은 위험하다. 꼭 사용해야 하는 상황이 아니면 지역변수를 사용해야 한다.

## 변수의 생명 주기

### 1. 지역 변수의 생명 주기

변수는 자신이 선언된 위치에서 생성되고 소멸한다. 즉 전역변수의 생명 주기는 애플리케이션 생명 주기와 같다. 하지만 함수 내부에 선언된 지역 변수는 함수가 호출되면 생성되고 종료되면 소멸한다.

```javascript
function foo() {
  var x = 'local';
  console.log(x); //local
  return x;
}

foo(); // 'local'

console.log(x); // 참조에러
```

지역 변수 x 는 foo 함수가 호출되기 전까지는 생성되지 않는다. foo 함수가 호출이 되야 내부 선언문이 실행되기 때문이다. 자바스크립트의 선언문은 런타임 이전이 실행된다고 했다.

하지만 이건 전역 변수에 한정된 것이다. 위의 함수 내부의 선언문은 함수가 호출되면 함수 몸체의 다른 문들이 순차적으로 실행되기 이전에 함수 내부에서 호이스팅이 일어나고 실행되면서 할당이 되고 함수 실행이 종료되면 x 변수도 소멸하여 생명 주기가 종료된다.

대부분 함수 내부의 변수는 함수의 생명 주기와 일치하지만 지역 변수가 함수보다 오래 생존하는 경우도 있다.

```javascript
// 함수 내부의 호이스팅
var x = 'global';

function foo() {
  console.log(x);
  var x = 'local';
}

foo(); // undefined
```

### 2. 전역 변수의 생명 주기

var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 말한다.

###### 📌전역 객체(global object)

> 전역 객체는 코드가 실행되기 전에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체다. 클라이언트 사이드환경(브라우저) 에서는
>
> window 객체, 서버 사이드 환경(node.js)에서는 global 객체를 의미한다.

### 3. 전역 변수의 문제점

- ##### 암묵적 결합

> 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것이다. 변수의 유효 범위가 크면 의도치 않게 상태가 변경될수 있는 위험성도 높아진다.

- ##### 긴 생명 주기

> 전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비하고, 상태가 변경될 시간도 길고 기회도 많다.

- ##### 스코프 체인 상에서 종점에 존재

> 변수를 검색할 떄 전역 변수가 가장 마지막에 검색된다는 것을 말한다. 그래서 검색 속도가 가장 느리다.

- ##### 네임스페이스 오염

> 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있어도 하나의 전역 스코프를 공유 한다는 것이다. 따라서 다른 파일에 같은 이름으로 명명된 전역 변수가 있으면 예상치 못한 결과를 가져올 수 있다.

## 전역 변수의 사용을 억제하는 방법

### 1. 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```javascript
(function () {
  var foo = 10;
  // .......
})();

console.log(foo); // 참조에러
```

### 2. 네임스페이스 객체

전역에 네임스페이스역할을 담당할 객체를 생성하고 전역 변수처럼 프로퍼티를 추가하는 방법

```javascript
var MYAPP = {}; // 네임스페이스 객체

MYAPP.name = 'lee';

console.log(MYAPP.name); // 'lee'

var MYAPP = {};

MYAPP.person = {
  name: 'lee',
  address: 'seoul',
};

console.log(MYAPP.person.name); // 'lee'
```

### 3. 모듈 패턴

모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 이것은 클로저를 기반으로 동작하며 캡슐화도 가능하다.

```javascript
var Counter = (function () {
  var num = 0;

  //외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

// num 변수는 외부로 노출되지 않는다.

console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
```

출처 https://poiemaweb.com/
