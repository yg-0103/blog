## 원시값과 객체의 비교

자바스크립트는 기본적으로 크게 데어터 타입을 원시타입과 객체 타입으로 나눌수 있다.

기본적으로 원시타입과 객체 타입이 다른 점은

- 원시 타입의 값은 변경 불가능한 값(immutable value)인데 반해 객체 타입의 값은 변경 가능한 값(mutable value)다.
- 원시값을 변수에 할당하면 메모리공간에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 참조값이 저장된다.
- 원시값을 가지는 변수를 다른 변수에 할당하면 원시값이 복사되어 전달된다. 이것이 값에 의한 전달이라 한다. 이에비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

## 원시값

### 1. 변경 불가능한 값

한 번 생성된 원시값은 읽기 전용 값으로서 변경할 수 없다. 이말은 변수와 나누어 생각해야 한다. 변수는 값을 저장하기 위해 확보한 메모리 공간 또는

그 공간을 식별하기 위해 붙인 이름이고 값은 변수에 저장된 데이터이다. 여기서 변경불가능한 것은 변수가 아니라 값이다.

변수에 재할당을 하게되면 원시값이 바뀌어 저장되는 것이 아니고 새로운 메모리공간에 저장을 하게 된다. 즉 원시값이 바뀌는 것은 아니다.

### 2. 문자열의 불변성

원시값인 문자열은 다른 원시값과 다르게 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

📌유사 배열 객체

> 유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 이러한 특성으로 for문으로
>
> 순회할 수도 있다.

```javascript
// 유사 배열 객체로 인덱스로 각문자에 접근할수 있지만 문자열은 원시 타입이므로 값을 변경할수 없다.

var name = 'yeongoo';

name[0] = 'Y';

console.log(name); // "yeongoo"

// 값을 재할당하는 것은 물론 가능하다.

var name = 'yeongoo';

name = 'sarang';

console.log(name); // "sarang"
```

### 3. 값에 의한 전달

ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 나와 있지 않다.

```javascript
var num = 10;

var copy = num;

console.log(num === copy); // true

num = 20;

console.log(num === copy); // false
```

위와 같은 상황일 때 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 결국 값의 의한 전달도 사실은 값을 전달하는 것이

아니라 메모리 주소를 전달한다. 처음에는 두 변수가 같은 메모리 주소를 가리키고 있지만 두 변수 중 하나의 변수에 원시값을 재할당하는 시점에서는

결국 두변수의 원시값은 서로 다른 메모리 공간에 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.

## 객체

객체는 프로퍼티의 개수가 정해져 있지 않고 동적으로 추가 또는 삭제, 변경도 가능하고 프로퍼티의 값에 제약도 없기 때문에 원시값과 다르게 확보해야 할

메모리 공간의 크기를 정해 둘 수 없다.

원시값은 상대적으로 적은 메모리를 소모하지만 객체는 경우에 따라 크기가 매우 클 수도 있다. 따라서 객체는 원시값과는 다른 방식으로 동작하도록 설계되

어 있다.

###### 📌자바스크립트 객체의 관리방식

> 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다. 대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만
>
> 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다. V8 자바스크립트 엔진 에서는 프로퍼티에 접근을 하기위해 히든클래스
>
> 라는 방식을 사용해 프로퍼티에 접근하는 성능을 보장한다.

### 1. 변경 가능한 값

객체 타입의 값은 변경 가능한 값(mutable value)이다.

원시 타입은 값을 할당한 변수가 가리키는 메모리 주소를 통해 원시값에 접근할 수 있다. 즉 원시값을 할당한 변수는 그 값 자체를 갖는다.

하지만 객체 타입은 변수가 가리키는 메모리 주소를 통해 접근하면 참조값(reference value)에 접근 할 수 있다. 참조값은 객체가 저장된 메모리주소 그 자체다.

```javascript
var user = {
  name: 'yeongoo',
};

console.log(user); // {name: 'yeongoo'} 참조값을 통해 식제 객체에 접근해서 그 객체를 반환한다.
```

원시값을 할당한 변수의 경우 변수는 원시값 그제차를 갖는다고 표현한다. 하지만 객체를 할당한 변수의 경우 객체를 참조하고 있다 또는 변수는 객체를 가리키고 있다고 표현한다.

객체 타입은 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 삭제할 수도 있다.

```javascript
var user = {
  name: 'yeongoo',
};

user.name = 'sarang'; // 프로퍼티 값 갱신

user.age = '31'; // 프로퍼티 생성

console.log(user); // {name: 'sarang', age: 31}
```

객체를 변경할 때마다 원시값처럼 이전 값을 복사해서 새롭게 생성하게되면 명확하고 신뢰성이 있겠지만 객체 자체가 크기가 매우 클 수도 있고 값도 일정하지 않으며 프로퍼티 값이 객체일 수도 있어서 복사를 해서 생성하게 되면 메모리 효율이 떨어지고 성능이 나빠진다.

따라서 메모리를 효율적으로 사용하기위해 객체는 변경 가능한 값으로 설계되어 있다. 객체의 이러한 구조적 단점 때문에 여러 개의 식별자가 하나의 객체를 공유 할 수도 있다.

###### 📌얕은 복사(shallow copy)와 깊은 복사(deep copy)

> 얕은 복사는 객체를 프로퍼티 값으로 갖는 경우 한 단계까지만 복사하는 것을 말하고 깊은 복사는 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.

```javascript
var obj = {
  a: { b: 2 },
  f() {},
};

// 얕은 복사
var o = { ...obj }; // obj 과 o 는 다른 메모리 주소를 가리키지만 내부에 a라는 프로퍼티 키가 가르키는 객체의 메모리 주소는 같다.
console.log(obj === o); // false
console.log(obj.a === o.a); // true

// 얕은 복사
var o = Object.assign({}, obj); // obj 이라는 객체를 새로운 빈객체에 넣어서 o라는 변수에 할당
console.log(o === obj); // false
console.log(o.a === obj.a); // ture

// JSON.pase와 JSON.stringify를 사용한 깊은 복사
var o = JSON.parse(JSON.stringify(obj));
console.log(o === obj); // false
console.log(o.a === obj.a); // false
console.log(o.f); // undefined
// 이 방법은 method는 복사할 수 없다.
```

얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 이 말은 두 객체가 가리키는 메모리의 주소는 다르다는 소리이다. 하지만 얕은 복사의 경우

객체에 중첩되있는 객체의 경우 참조값을 복사하고 깊은 복사의 경우 객체에 중첩되있는 객체까지 모두 복사해서 원시값처럼 완전한 복사본을 만든다.

### 2. 참조에 의한 전달

여러 개의 식별자가 하나의 객체를 공유하게 되면 문제가 발생할 수 있다.

```javascript
var user = {
  name: 'yeongoo',
};

// 얕은 복사 copy 와 persond은 동일한 객체를 가리킨다
var copy = user;

console.log(copy === user); // true

copy.name = 'Kim';

user.age = 31;

// 서로 영향을 주고 받는다.
console.log(user); // {name: "Kim", addresss: "Seoul"}
console.log(copy); // {name: "Kim", addresss: "Seoul"}
```

값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달하는 면에선 동일하지만 그 메모리 공간에 저장되어 있는 값이 참조값이냐 원시값이냐의 차이가 있다.

출처 https://poiemaweb.com/
